# 1.改进快排(预处理)
- 在数组已经有序的情况下，快排将退化为冒泡排序。
- 将数组第一个元素，最后一个元素与中间元素排序。取三者中中间那个做枢轴即可。

# 2.树、二叉树、森林的转换
- 树转化为二叉树:
	- 每个结点的左指针指向它的第一个孩子, 右指针指向它在树中相邻的右兄弟, “左孩子右兄弟”
	- 因为根结点没有兄弟结点, 所以生成的二叉树没有右子树。
	- 画法: 在兄弟结点之间加一连线;
			对每个节点, 只保留它与第一个孩子的连线, 其余的全部去掉
			以树根为轴心, 顺时针旋转45度

- 森林转化为二叉树:
	- 先将森林中每棵树转化为二叉树;
	- 由于任意一颗转化来的二叉树的右子树必为空, 所以将第二棵(如果有)二叉树插入到第一棵树的根结点作为它的右孩子, 剩下的树以此类推
	- 画法: 将森林中每棵树转化为二叉树; 将每棵树的根结点相连; 以第一棵树为轴顺时针旋转45度

- 二叉树转化为森林:
	- 与森林转化二叉树操作相反即可
	- 根结点及它的左子树即为森林中第一棵树转化来的二叉树
	- 根结点的右孩子(如果有)以及右孩子的右孩子, 分别为原本森林中的第2,3棵树
	- 所以将根结点和右孩子的连接断开
	- 对于每棵拆分开的二叉树的每个节点, 左孩子才是该节点真正的孩子, 右孩子是它的兄弟
	- 逆时针旋转45度, 将右孩子的连接断开, 并连到根结点上

# 3.平衡二叉树
- 左右子树高度差的绝对值不超过1的二叉树
- 平衡因子: 左右子树高度之差
- 平衡二叉树的左右子树也都是平衡二叉树
- 插入删除: 
	- 与二叉排序树同
	- 插入或删除节点后, 要判断二叉树是否平衡, 不平衡则要做出调整
		- 调整:
			- 先找到插入路径上距离插入节点最近的平衡因子大于1的节点A, 再对A为根的子树, 在保持二叉排序树特性的情况下调整, 使其平衡
			- LL(右单旋转): 由于在节点A的左孩子(L)的左子树(L)插入了新节点, 需要一次向右的旋转: 将A的左孩子B向右上旋转代替A成为根结点, 
				将A向右下旋转成为B的右孩子, 而B的原右子树则作为A的左子树
			- RR(左单旋转): 在A的右孩子的右子树插入节点, 需要向左旋转, A的右孩子B向左上旋转代替A, A向左下旋转, B的原左子树作为A右子树
			- LR(先左后右双旋转): 同理, A的左孩子右子树插入节点, 先将A的左孩子的右子树的根结点C向左上旋转代替B, 此时C为A之左孩子,
				C原左孩子(如有)变为B之右孩子, C原右孩子仍为右孩子。
				再将C向右上旋转代替A, 此时C为根结点, A为C之右孩子, 原C右孩子为A之左孩子
			- RL(先右后左双旋转): LR之反序

# 4.层序遍历代码(借助队列)
- 入队根结点
- 若队列不空, 元素出队, 若该元素有左孩子, 左孩子入队; 若有右孩子, 右孩子入队;
- 循环, 直到队列为空

# 5.逆序链表(leetcode)

# 6.树的遍历(先根后根)
- 先根(类似先序遍历):
	- 若树非空: 
	- 先访问根节点
	- 再依次遍历根结点的每棵子树, 遍历子树时仍按照先根后子树的顺序
	- 其遍历序列与该树转化的二叉树的先序遍历相同

- 后根(与先根相反):
	- 若树非空:
	- 先访问节点的子树, 简单来说就是取最底端的节点
	- 再访问子树的根结点, 遍历子树时仍按照先子树后根的顺序
	- 序列于二叉树之中序遍历相同

# 7.筛选法建堆
- 有n个节点的完全二叉树, 最后一个节点是n/2(向下取整)个节点的孩子, 对以n/2个节点为根的子树进行筛选, 调整大小使之成堆
- 之后向前依次对n/2-1~1个节点进行筛选, 看该节点值是否大于(小于)其左右节点值, 若不是则调整
- 调整后可能破坏下一级的堆结构, 继续使用上述方法对下一级堆做调整, 直到以该节点为根的完全二叉树构成堆为止
- 如此反复直到根结点

# 8.Prim, Kruscal算法区分, 性能

# 9.Dijkstra, Floyd

# 10.交换二叉树左右节点

# 11.绪论

# 12.森林遍历
- 先序遍历:
	- 访问森林中第一棵树的根结点
	- 先序遍历第一棵树中根结点的子树森林
	- 先序遍历除第一棵树外的其余子树构成的森林
	- 其实就是森林中每棵树的先根遍历构成的集合

- 中序遍历:
	- 同理, 每棵树的后根遍历组成的集合

- 对应关系:
	- 树           森林            二叉树
	  先根遍历      先序遍历         先序遍历
	  后根遍历      中序遍历         中序遍历
 
