# 1.改进快排(预处理)
- 在数组已经有序的情况下，快排将退化为冒泡排序。
- 将数组第一个元素，最后一个元素与中间元素排序。取三者中中间那个做枢轴即可。

# 2.树、二叉树、森林的转换
- 树转化为二叉树:
	- 每个结点的左指针指向它的第一个孩子, 右指针指向它在树中相邻的右兄弟, “左孩子右兄弟”
	- 因为根结点没有兄弟结点, 所以生成的二叉树没有右子树。
	- 画法: 在兄弟结点之间加一连线;
			对每个节点, 只保留它与第一个孩子的连线, 其余的全部去掉
			以树根为轴心, 顺时针旋转45度

- 森林转化为二叉树:
	- 先将森林中每棵树转化为二叉树;
	- 由于任意一颗转化来的二叉树的右子树必为空, 所以将第二棵(如果有)二叉树插入到第一棵树的根结点作为它的右孩子, 剩下的树以此类推
	- 画法: 将森林中每棵树转化为二叉树; 将每棵树的根结点相连; 以第一棵树为轴顺时针旋转45度

- 二叉树转化为森林:
	- 与森林转化二叉树操作相反即可
	- 根结点及它的左子树即为森林中第一棵树转化来的二叉树
	- 根结点的右孩子(如果有)以及右孩子的右孩子, 分别为原本森林中的第2,3棵树
	- 所以将根结点和右孩子的连接断开
	- 对于每棵拆分开的二叉树的每个节点, 左孩子才是该节点真正的孩子, 右孩子是它的兄弟
	- 逆时针旋转45度, 将右孩子的连接断开, 并连到根结点上

# 3.平衡二叉树
- 左右子树高度差的绝对值不超过1的二叉树
- 平衡因子: 左右子树高度之差
- 平衡二叉树的左右子树也都是平衡二叉树
- 插入删除: 
	- 与二叉排序树同
	- 插入或删除节点后, 要判断二叉树是否平衡, 不平衡则要做出调整
		- 调整:
			- 先找到插入路径上距离插入节点最近的平衡因子大于1的节点A, 再对A为根的子树, 在保持二叉排序树特性的情况下调整, 使其平衡
			- LL(右单旋转): 由于在节点A的左孩子(L)的左子树(L)插入了新节点, 需要一次向右的旋转: 将A的左孩子B向右上旋转代替A成为根结点, 
				将A向右下旋转成为B的右孩子, 而B的原右子树则作为A的左子树
			- RR(左单旋转): 在A的右孩子的右子树插入节点, 需要向左旋转, A的右孩子B向左上旋转代替A, A向左下旋转, B的原左子树作为A右子树
			- LR(先左后右双旋转): 同理, A的左孩子右子树插入节点, 先将A的左孩子的右子树的根结点C向左上旋转代替B, 此时C为A之左孩子,
				C原左孩子(如有)变为B之右孩子, C原右孩子仍为右孩子。
				再将C向右上旋转代替A, 此时C为根结点, A为C之右孩子, 原C右孩子为A之左孩子
			- RL(先右后左双旋转): LR之反序

# 4.层序遍历代码(借助队列)
- 入队根结点
- 若队列不空, 元素出队, 若该元素有左孩子, 左孩子入队; 若有右孩子, 右孩子入队;
- 循环, 直到队列为空

# 5.逆序链表(leetcode)
- 迭代(双指针):
	- 初始化两指针, 一指向头节点, 一指向NULL ListNode * cur = head, * pre = nullptr;
	- ListNode tmp = cur.next; 暂存cur的下一节点
	- cur.next = pre;
	- pre = cur;
	- cur = tmp;
	- 人话版本: 先存储头节点的下一个节点, 将原链表第一个节点放在链表尾, 此时原链表头节点的下一个节点, 也就是第二个节点成为现头节点
		- 原尾部空指针指向第一个节点
		- 继续存储现头节点的下一个节点, 让现头节点.next指向已被放在链表尾的原头节点, 这样就实现第一二节点的逆置
		- 以此类推直到头节点为null, 则所有节点都已逆置
	- 要点: 链表问题中最忌断链, 所以先存储头节点之下一个节点, 这样可有效避免断链
			实际上就是定义一额外链表, 用头插法不断的从原链表拆下节点接在新链表上

# 6.树的遍历(先根后根)
- 先根(类似先序遍历):
	- 若树非空: 
	- 先访问根节点
	- 再依次遍历根结点的每棵子树, 遍历子树时仍按照先根后子树的顺序
	- 其遍历序列与该树转化的二叉树的先序遍历相同

- 后根(与先根相反):
	- 若树非空:
	- 先访问节点的子树, 简单来说就是取最底端的节点
	- 再访问子树的根结点, 遍历子树时仍按照先子树后根的顺序
	- 序列于二叉树之中序遍历相同

# 7.筛选法建堆
- 有n个节点的完全二叉树, 最后一个节点是n/2(向下取整)个节点的孩子, 对以n/2个节点为根的子树进行筛选, 调整大小使之成堆
- 之后向前依次对n/2-1~1个节点进行筛选, 看该节点值是否大于(小于)其左右节点值, 若不是则调整
- 调整后可能破坏下一级的堆结构, 继续使用上述方法对下一级堆做调整, 直到以该节点为根的完全二叉树构成堆为止
- 如此反复直到根结点

# 8.Prim, Kruskal算法区分, 性能
- Prim: 初始时取图中任意一顶点, 之后取一个与当前顶点集合中距离最近(即边权值最短)的一个节点加入树, 如此反复直到所有节点都加入树, 此时必有n-1条边
	- 性能: 时间复杂度为O(|V|ˆ2)即顶点数, 不依赖于|E|即边数, 适用于求解边稠密的图的最小生成树

- Kruskal: 初始时为有n个顶点但无边的非连通图, 每个顶点自成一个连通分量。然后按照边的权值由小到大的顺序, 不断选取当前未被加入图且加入后不构成回路的边(
	若该边依附的顶点落在T中不同的连通分量上), 以此类推直到所有顶点都在一个连通分量上(使用并查集判断两个节点是否属于同一连通分量)
	- 性能: 最坏情况需要对每条边都扫描一次, 因此多用堆来存放边, 每次取最小边所需时间为O(log|E|), 每次使用并查集判断两节点是否属于同一连通分量需要O(a|V|)的时间, 可视为常量
			总时间复杂度为O(|E|log|E|), 不和顶点数相关, 适合边稀疏而顶点较多的图

- 区别: Prim先取一顶点, 后以已有顶点为主再添加边, 确保每次都扩张已有顶点集合
	   Kruskal先初始化所有顶点但没有边, 随后添加权值最小且不构成回路的边, 也就是连接任意两个连通分量的边。
	   Prim初始只有一个顶点, 逐步添加顶点; Kruscal初始有所有顶点但没有边, 逐步添加边

# 9.Dijkstra, Floyd(求解最短路径)
- Dijkstra(单源最短路径): 初始时把源点v0加入集合S, 集合S每加入一个新节点v, 都要更新源点v0到V-S各节点之间的最短距离
	- 三个辅助数组: final: 标记各顶点是否已找到最短路径, 即是否已加入到集合S
				  dist: 记录从源点v0到各节点的最短路径, 初始值为: 若v0到vi间有弧, 则值为弧的权值, 否则为∞
				  path: 表示从v0到顶点i之间的最短路径的前驱节点, 算法结束时可根据其值追溯v0到vi的最短路径
	- 流程: 置邻接矩阵arcs记录各有向边的权值, 集合S初始化为0;
			从顶点集合V-S中选出vi, 即以源点v0为出发点的最短的边的终点, 加入S
			修改从v0到V-S中任意一顶点vk可达的最短路径长度, 若dist[j]+arcs[j][k] < dist[k], 则更新dist[k]
			重复以上操作n-1次直到所有顶点都加入V
	- 与Prim相似之处: 都基于贪心策略
	- 性能: O(|V|ˆ2), 不适用于带有负权值边的图

- Floyd(各顶点之间最短路径): 遍历各个节点依次建立邻接矩阵, 记录当前节点到各节点之间的距离, 与Dijkstra类似更新最短路径
	- 性能: 时间复杂度O(|V|ˆ3), 如用Dijkstra求各顶点间最短路径则时间复杂度相同

# 10.交换二叉树左右节点(递归)
- 首先写好中断条件 if (!root) return nullptr;
- 递归定义一右节点为 invertTree(root.right)
- 左节点同
- 交换 root.left = RightNode; root.right = LeftNode;
- return root;

# 11.绪论
- 算法五个特性: 有穷性, 确定性, 可行性, 输入, 输出
- 数据结构三个特征: 逻辑结构, 存储结构, 数据的运算

# 12.森林遍历
- 先序遍历:
	- 访问森林中第一棵树的根结点
	- 先序遍历第一棵树中根结点的子树森林
	- 先序遍历除第一棵树外的其余子树构成的森林
	- 其实就是森林中每棵树的先根遍历构成的集合

- 中序遍历:
	- 同理, 每棵树的后根遍历组成的集合

- 对应关系:
	- 树           森林            二叉树
	  先根遍历      先序遍历         先序遍历
	  后根遍历      中序遍历         中序遍历
 
