# 1.线索二叉树的遍历
- 线性就是有顺序，更方便遍历的二叉树。
- 规定: 
	- 1.除了第一个节点和最后一个节点，每个节点都有一个直接前驱和一个直接后继
	- 2.每个节点除左右孩子指针外，另加两个左右tag指针，记录左右孩子的指示
		- tag==0: child指向自己的孩子; tag == 1: child指向自己的前驱/后继
	- 3.当节点左孩子为空时，左child指向自己的直接前驱。右孩子为空时，右child指向自己的直接后继
	- 4.根据遍历顺序不同，分为先/中/后序线索二叉树
	- 5.如何界定前驱后继: 根据遍历顺序不同确定前驱后继，而不是二叉树上直观的顺序

# 2.基数排序用静态链表实现(分配 回收)
- 分配即为以最高(低)位做划分排序的过程
- 回收即为将分配后的结果重新组建一个链表的过程
- 时间复杂度为O(d(n+r)), d为排序趟数(即元素最高位数)，n为元素个数，r为进制数

# 3.希尔排序
- 痛点: 直插排序平均时间复杂度为O(nˆ2)，但当元素表为正序时可缩短至O(n)，由此可见直插更适用于基本有序的线性表，希尔排序因此而生
- 基本思想: 先将待排序表划分为形如[i,i+d,i+2d,...,i+kd]之特殊子表，即将相隔同个“分量”的元素划分在同一组
	- 对各个子表进行插入排序，当整个元素表已“基本有序”时，再对全体记录进行一次直插排序
- 例如:[49,38,65,97,76,13,27,49,55,4]，先取一个不大于线性表长度的增量d(这里取5)，将表分为d组[49,13],[38,27],[65,49],[97,55],[76,4]
	- 则第一趟排序结果为: 13,27,49,55,4,49,38,65,97,76
	- 第二趟d取3，将表分为[13,55,38,76],[27,4,65],[49,49,97]
	- 第二趟排序结果为: 13,4,49,38,27,49,55,65,97,76
	- 此时整组表已“基本有序”，对全体记录进行一次直插排序
- 性能: 时间复杂度当n在某范围时为O(nˆ1.3)，最坏为O(nˆ2)
- 稳定性: 不稳定

# 4.AOV网,AOE网
- 区别: AOE网有权值，AOV无。AOE网用边表示活动，AOV网用节点
- AOV网可求拓扑排序，因为只关注节点的前驱后继关系。
- AOE网可求关键路径，因为带权值的边代表有开销的活动。
- 节点最早开始时间: 进入该节点的所有边中最长的那一条，递归，多个节点求和
- 节点最晚开始时间: 最后一个节点的最早开始时间，减去该节点最长的前驱(逆拓扑排序)
- 活动最早开始时间: 该活动弧的起点所表示的事件的最早开始时间
- 活动最晚开始时间: 在该活动弧的起点与终点之间的所有活动中，用时间最长的那个减去该活动，差额即为最晚开始时间
	- 若最晚开始时间为0，则证明该活动必须如期完成，为关键活动。
- 关键路径: 所有活动最晚开始时间为0的活动集合构成的路径。缩短关键路径可减少整个工程所需的时间
	- 但不能任意缩短，否则原关键路径可能不再关键

# 5.邻接表转化为邻接矩阵
- 定义邻接矩阵vector res = [边表.size()] [边表.size()]; 初始化各元素值为0
- 外层循环: 遍历邻接表的边表，取节点为a，int n1 = a.val
	- 内层循环： 遍历a所在之顶点表，int n2 = a.val; a = a.next; 
	- res[n1] [n2] = 1;
	- 对角线各元素均为1

# 6.二叉排序树
- 删除: 删除某节点后，若左子树空，用右子填补; 反之同理; 左右子树均不空, 用中序遍历第一个子填补;
- 查找长度: 与哈夫曼树相同, 层数乘该层节点数量, 但最后除以节点数
- 唯一性: 相同节点的不同插入顺序可能导致排序树不同

# 7.堆排序
- 构建堆: 从数组中依次取出元素构建堆，当遇到根结点不再是最大值时，交换最大值与根结点，小顶堆同理。
- 排序: 将堆顶元素与堆最后一个元素交换，再对交换后的堆进行调整让它保持大顶或小顶

# 8.稀疏矩阵
- 压缩后不再有随机存储的特性
- 三元组: 一个n* 3的二维数组，三列参数分别存储元素的行，列以及值
